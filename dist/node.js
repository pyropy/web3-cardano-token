!function(e,r){if("object"==typeof exports&&"object"==typeof module)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var t=r();for(var s in t)("object"==typeof exports?exports:e)[s]=t[s]}}(global,(function(){return(()=>{"use strict";var e,r,t={63:e=>{e.exports=require("@emurgo/cardano-serialization-lib-browser")},111:e=>{e.exports=require("@emurgo/cardano-serialization-lib-nodejs")},700:e=>{e.exports=require("emurgo-message-signing")},216:e=>{e.exports=require("emurgo-message-signing-nodejs")}},s={};function o(e){var r=s[e];if(void 0!==r)return r.exports;var n=s[e]={exports:{}};return t[e](n,n.exports,o),n.exports}o.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return o.d(r,{a:r}),r},r=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,o.t=function(t,s){if(1&s&&(t=this(t)),8&s)return t;if("object"==typeof t&&t){if(4&s&&t.__esModule)return t;if(16&s&&"function"==typeof t.then)return t}var n=Object.create(null);o.r(n);var a={};e=e||[null,r({}),r([]),r(r)];for(var i=2&s&&t;"object"==typeof i&&!~e.indexOf(i);i=r(i))Object.getOwnPropertyNames(i).forEach((e=>a[e]=()=>t[e]));return a.default=()=>t,o.d(n,a),n},o.d=(e,r)=>{for(var t in r)o.o(r,t)&&!o.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},o.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{o.d(n,{default:()=>g});const e=require("base-64");var r=o.n(e);const t=require("ms");var s=o.n(t);const a=require("parse-headers");var i=o.n(a);const d=require("buffer"),f=new class{async load(){this._wasm&&this._wasm2||(this.isBrowser="undefined"!=typeof window,this._wasm=this.isBrowser?await Promise.resolve().then(o.t.bind(o,63,23)):await Promise.resolve().then(o.t.bind(o,111,23)),this._wasm2=this.isBrowser?await Promise.resolve().then(o.t.bind(o,700,23)):await Promise.resolve().then(o.t.bind(o,216,23)))}get Cardano(){return this._wasm}get Message(){return this._wasm2}},u=!!process.env.DEBUG_WEB3;function c(e,...r){u&&console.log(e,r)}const g={sign:async(e,t="1d",o={})=>{const n=(e=>{const r='"expires_in" argument should be a number of milliseconds or a string representing a timespan eg: "1d", "20h", 60';if("string"==typeof e){const t=s()(e);if(void 0===t)throw new Error(r);return new Date(Date.now()+t).toUTCString()}if("number"==typeof e)return new Date(Date.now()+e).toUTCString();throw new Error(r)})(t);(e=>{for(const r in e){const t=e[r];if("Expire-Date"===r)throw new Error('Please do not rewrite "Expire-Date" field');if("Web3-Token-Version"===r)throw new Error('Please do not rewrite "Web3-Token-Version" field');if("string"!=typeof t)throw new Error("Body can only contain string values")}})(o);const a=(e=>{const r=[];for(const t in e)r.push(`${t}: ${e[t]}`);return r.join("\n")})({"Web3-Token-Version":1,"Expire-Date":n,...o});if("function"!=typeof e)throw new Error('"signer" argument should be a function that returns a signature eg: "msg => web3.eth.personal.sign(msg, <YOUR_ADDRESS>)"');var i=await e(a);let d,f;if("string"==typeof i?d=i:(d=i.signature,f=i.key),"string"!=typeof d)throw new Error('"signature" argument should be a function that returns a signature string (Promise<string>)');return r().encode(JSON.stringify({signature:d,key:f,body:a}))},verify:async e=>{if(!e||!e.length)throw new Error("Token required.");try{var t=r().decode(e)}catch(e){throw new Error("Token malformed (must be base64 encoded)")}if(!t||!t.length)throw new Error("Token malformed (must be base64 encoded)");try{var{body:s,signature:o,key:n}=JSON.parse(t)}catch(e){throw new Error("Token malformed (unparsable JSON)")}if(!s||!s.length)throw new Error("Token malformed (empty message)");if(!o||!o.length)throw new Error("Token malformed (empty signature)");let a,u;if(await f.load(),n){const e=f.Message.COSESign1.from_bytes(d.Buffer.from(d.Buffer.from(o,"hex"),"hex"));c("message",e);const r=e.headers().protected().deserialized_headers();a=f.Cardano.Address.from_bytes(r.header(f.Message.Label.new_text("address")).as_bytes());const t=f.Message.COSEKey.from_bytes(d.Buffer.from(n,"hex"));u=f.Cardano.PublicKey.from_bytes(t.header(f.Message.Label.new_int(f.Message.Int.new_negative(f.Message.BigNum.from_str("2")))).as_bytes());const s=e.signed_data().to_bytes(),g=d.Buffer.from(s).toString("utf-8"),h=f.Cardano.Ed25519Signature.from_bytes(e.signature());if(!u.verify(s,h))throw new Error("Message integrity check failed (has the message been tampered with?)");const m=i()(g);if(m["expire-date"]&&new Date(m["expire-date"])<new Date)throw new Error("Token expired")}else{const e=f.Message.COSESignature.from_bytes(d.Buffer.from(o,"hex")).headers().protected().deserialized_headers();a=f.Cardano.Address.from_bytes(e.header(f.Message.Label.new_text("address")).as_bytes()),u=f.Cardano.PublicKey.from_bytes(e.key_id())}c("publicKey",d.Buffer.from(u.as_bytes()).toString("hex"));const g=((e,r)=>{c("In verifyAddress",e,r);let t="";try{const t=f.Cardano.RewardAddress.from_address(e);if(t){const e=d.Buffer.from(t.payment_cred().to_keyhash().to_bytes()).toString("hex")===d.Buffer.from(r.hash().to_bytes()).toString("hex");return{status:e,msg:e?"Verified Reward Address":"Reward Address not verified",code:9}}c("Step verifyAddress",1);const s=r.hash();c("Step verifyAddress",2);const o=f.Cardano.BaseAddress.from_address(e).stake_cred().to_keyhash();c("Step verifyAddress",3);const n=f.Cardano.BaseAddress.new(e.network_id(),f.Cardano.StakeCredential.from_keyhash(s),f.Cardano.StakeCredential.from_keyhash(o));c("Step verifyAddress",4);const a=e.to_bech32()===n.to_address().to_bech32();return c("Step verifyAddress",5,a),{status:a,msg:a?"Valid Address":"Base Address does not validate to Reconstructed address",code:1}}catch(e){c("Err verifyAddress",e),t+=` ${e.message}`}return{status:!1,msg:`Error: ${t}`,code:3}})(a,u);if(!g.status)throw new Error(`Address verification failed: (${g.message} (${g.code}))`);return{address:a.to_bech32(),network:a.network_id()}}}})(),n.default})()}));